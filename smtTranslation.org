#+TITLE: Smt Translation
#+AUTHOR: Robert Smith
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,11pt]
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER: \usepackage{multirow}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \newcommand*\BitAnd{\mathbin{\&}}
#+LATEX_HEADER: \newcommand*\BitOr{\mathbin{|}}
#+LATEX_HEADER: \newcommand*\ShiftLeft{\ll}
#+LATEX_HEADER: \newcommand*\ShiftRight{\gg}
* Introduction
Timed Automata are a commonly used representation for modelling the behavior of
systems with real-time semantics.

Bounded Satisfiability Checking is a process in which timed automata can be
verified against a property. The TA system along with the desired property are
converted into a format suitible for parsing by a SAT or SMT solver. Then the
solver is tasked with finding a counterexample to the property. Since TA traces
are infinite in length, we restrict ourselves to traces of the form
\(s_1s_2,\ldots s_{l-1}(s_ls_{l+1}\ldots s_{n-1}s_n)^\omega\). These
lasso-shaped traces consist of an initial sequence of states up until
\(s_{l-1}\), followed by a loop that can be repeated an inifinite amount of
times to form the full trace. Since the beginning of the loop is allowed to
occur anywhere within the sequence, the only variable is the number of distinct
states \(n\). Bounded Satisfiability Checking refers to checking if a given
property is satisfied over lasso-shaped traces of up to length \(n\).

Current examples of TA bounded model checkers include XX, YY, and de-facto
standard Uppaal. TACK is a tool focused on allowing for the expression of TA
properties in Metric Interval Temporal Logic, a rich ...

TACK translates both the TA and the property to be verified into CLTLoc.
Constraint Linear Temporal Logic (over clocks) is a variant of

Zot ..

Sbvzot is a very sucessful solver which takes advantage of bit vector logic...

To further improve the performance of TACK, we wish to directly translate the
network of timed automata into the SMT-LIB format, skipping the intermediate
CLTLoc representation. While CLTLoc is an elegant expressive language, there is
a significant overhead in
* Preliminaries
** Bit-Vector Logic
A BitVector is an array of binary values, or bits. BitVectors are interpreted
using two's complement arithmetic to produce integer values, and their length
can be any positive integer (\(\mathbb{Z}^+\)). We use the notation
\(\overleftarrow{x}_{[n]}\) to represent a BitVector \(x\) of length \(n\), but
this can be simplified to \(\overleftarrow{x}\) if the length is clear. Bits are
numbered from right to left, with the rightmost, least significant bit labelled
as 0, and the leftmost, most significant bit labelled as \(n-1\). As an example,
the constant vector \(-4\) of length 5 would be written as
\(\overleftarrow{-4}_{[5]}\), which would expand to \(11100\). We can also
reference individual bits in the vector using the notation
\(\overleftarrow{x}_{[n]}^{[i]}\) to \(extract\) the \(i\)th bit from the
BitVector \(x\). It is also possible to extract a sub-vector with the notation
\(\overleftarrow{x}_{[n]}^{[j:i]}\), where \(n>j\geq i\geq 0\). This extracts a
vector of length \(j-i+1\) whose rightmost bit corresponds to the \(i\)th bit of
\(x\) and whose leftmost bit corresponds to the \(j\)th. Similarly,
\(concatenation\) operates on two bitvectors by combining their bit arrays.
\(\overleftarrow{x}_{[n]} :: \overleftarrow{y}_{[m]}\) returns a new BitVector
\(\overleftarrow{z}_{[n+m]}\) where \(\overleftarrow{z}^{[m-1:0]} =
\overleftarrow{y}\), and \(\overleftarrow{z}^{[m+n-1:m]} = \overleftarrow{x}\).

The usual arithmetic operations of addition \(+\) and subtraction \(-\) are
defined over two BitVectors of the same length. BitVectors also support the
bitwise operators not \(\neg\), disjuction \(\lor\), conjunction \(\land\),
equivalence \(\iff\).

** Timed Automata
Let \(AP\) be a set of atomic propositions, and let \(Act\) be a set of events.
In addition we define a null event \(\tau\). \(Act_{\tau}\) is the set \(Act
\cup \{\tau\}\). Let \(X\) be a finite set of clocks, and \(Int\) a finite set
of integer-valued variables. \(\Gamma(X)\) is the set of clock contraints, where
a clock constraint \(\gamma\) is a relation \(x \sim c \BitOr \neg \gamma\BitOr
\gamma \land \gamma\), where \(x \in X\), \(\sim \in \{<,=\}\), and \(c \in
\mathbb{N}\). \(Assign(Int)\) is a set of variable assignments of the form \(y
:= exp\), where \(exp := exp + exp\BitOr exp - exp\BitOr exp \times exp\BitOr exp \div
exp\BitOr n\BitOr c\), \(y \in Int\) and \(c \in \mathbb{Z}\). \(\Gamma(Int)\) is
the set of integer variable constraints, where a variable constraint \(\gamma\)
is defined as \(\gamma := n \sim c\BitOr n \sim n'\BitOr \neg \gamma\BitOr \gamma
\land \gamma\), where \(n\) and \(n'\) are integer variables, \(c \in
\mathbb{Z}\), and \(\sim \in \{<,=\}\). A Timed Automaton with variables is
defined as the tuple \(\mathcal{A} = <AP,X, Act_{\tau}, Int, Q, q_0, v_{var}^0,
Inv, L, T>\). \(Q\) is the finite set of states of the timed automaton, and
\(q_0 \in Q\) is the initial state. \(Inv : Q \rightarrow \Gamma(X)\) is a
function assigning each state to a (possibly empty) set of clock constraints.
The labelling function \(L: Q \rightarrow \mathcal{P}(AP)\) assigns each state
to a subset of the atomic propositions. Each transition \(t \in T\)
has the form \(T \subset Q \times Q \times Act_{\tau} \times \Gamma(X)
\times \Gamma(Int) \times \mathcal{P}(X) \times \mathcal{P}(Assign(Int))\),
consisting of a source and destination state, an action, a set of clock and
variable guards, and a set of clocks to be reset when the transition fires.

** Bounded Satisfiability Checking
(here sketch both ta->CLTLoc encoding and sbvzot translation)
* TA Encoding
Using BitVector logic, we have the ability to group logically connected
propositions into a Vector, granting significant speedups on operations
performed on every element of the vector.

When encoding the constraints of the system, it is convienent to write that a
constraint will hold over every discrete time position in the trace. As an
example, consider a transition with an guard \(x_i < 5\). When formalizing the
constraints, it would be simpler to have a formula of the type \(transition
\rightarrow constraint\) that we can assert over every time position. Therefore
we will use BitVectors of length \(k+2\), where each position in the BitVector
represents the formula at a different moment in time.

This encoding, while convienent, is not very efficient. Since only one
transition is active at a time, it is more compact to store the currently active
transition as a binary number over \(\lceil\log_2 |T|\rceil\) bits, where \(T\)
is the set of transitions. Therefore we will create \(\lceil\log_2 |T|\rceil\)
BitVectors of length \(k+2\) to represent the active transition of the TA over
time. In order to be able to convienently refer to individual elements of the
set, we will define aliases which refer to unique combinations of the
BitVectors. This will give us the convience of the individually-named BitVectors
while retaining the efficiency of the compact approach. This method will be
formalized below for the encoding of the states, transitions, and variables of
the Timed Automata.

For a model with a time bound of k, and a timed automaton with n distinct
transitions, we represent the active transition of the automaton at different
time instances as follows:

//#+ATTR_LATEX: :caption Representation of n elements over time with \log_2 n BitVectors
|                                 | k+1, \(\ldots\), 1, 0                                           |
|---------------------------------+-----------------------------------------------------------------|
|                               0 | \(\overleftarrow{sb_{i,0}}_{[k+2]}\)                            |
|                               1 | \(\overleftarrow{sb_{i,1}}_{[k+2]}\)                            |
|                             ... | ...                                                             |
| \(\lceil \log_2 n_i \rceil -1\) | \(\overleftarrow{sb_{i, \lceil \log_2 n_i \rceil -1}}_{[k+2]}\) |


** Transitions

In the traditional description of Timed Automata, a TA that does not perform a
discrete transition at a given time instance is said to perform a \(null
transition\), i.e. staying in the same state without firing any transition in
the set \(T\). In our encoding it is convienent to explicitly add a null
transition for each state \(q \in Q\) to the set of transitions. \(\forall_{q
\in Q} trans_{null_q} := <q, q, \tau, \varnothing, \varnothing, \varnothing,
\varnothing\) \(\mathcal{T} = T \cup \{\big\cup_{q \in Q} trans_{null_q}\}\)
\(trans_{null} := \big\BitOr_{q \in Q} trans_{null_q}\)

We define \(O: \mathcal{T} \rightarrow \mathbb{N}\) be a bijective
function mapping each transition to a natural number less than
\(|\mathcal{T}|\). We define BitVectors \(\{\overleftarrow{tb_1},
\overleftarrow{tb_2}, \ldots, \overleftarrow{tb_{\lceil
\log_2 |\mathcal{T}|\rceil}}\}\) of size \(k+2\). The BitVector for each
individual transition is defined as \(\overleftarrow{trans_t}_{[k+2]} :=
\big\BitAnd_{i=1}^{\lceil\log_2 |\mathcal{T}|\rceil} N_t(tb_i)\), where \(N_t(tb_i)\)
returns \(tb_i\) if the \(i\)th bit in the base two representation of \(O(t)\)
is 1, and returns \(\neg tb_i\) otherwise.

For clarity, let us consider an example TA with
\(\lceil\log_2 |\mathcal{T}|\rceil = 5\) and a transition \(t \in \athcal{T}\)
with \(O(t) = 5\). The base two representation of 5 is \(00101\), and therefore
\(\overleftarrow{trans_t}_{[k+2]}\) is equivalent to \((\neg tb_5 \BitAnd
\neg tb_4 \BitAnd tb_3 \BitAnd \neg tb_2 \BitAnd tb_1)\).

** States

For each TA \(\mathcal{A}_l \in \mathcal{A}\), we define a BitVector to
represent each state of the timed automaton. To do this we define each state as
the disjunction of all the transitions whose source is that state.

$$state_s := \big\BitOr\{trans_t : source(t) = s\}\ \ \forall_{s \in S}$$

For each TA \(\mathcal{A}_l \in \mathcal{A}\), let \(O: Q \rightarrow
\mathbb{N}\) be a bijective function mapping each state to a natural number less
than \(|Q|\). We define BitVectors \(\{\overleftarrow{sb_1},
\overleftarrow{sb_2}, \ldots, \overleftarrow{sb_{\lceil\log_2 |Q|\rceil}}\}\),
each of length \(k+2\). The BitVector for the individual state is then defined
as \(\overleftarrow{state_q}_{[k+2]} := \big\BitAnd_{i=1}^{\lceil\log_2 |Q|\rceil}
N_q(sb_i)\), where \(N_q(sb_i)\) returns \(sb_i\) if the \(i\)th bit in the base
two representation of \(O(q)\) is 1, and returns \(\neg sb_i\) otherwise.

** Variables

Bounded integer variables are treated slightly differently, because unlike
states and transitions, the possible values of a bounded integer variable are
not unrelated objects in a set, but integers that must respect the operations of
addition and subtraction. For each variable \(v_i \in Int\) we still construct a
bit representation \(\overleftarrow{vb_{i,j}}_{[k+2]}\), where each BitVector
has length \(k+2\). However the difference is that the values are encoded in 2s
complement notation, and the number of BitVectors is chosen so that the vectors
are capable of representing the entire range of values for the given bounded
integer variable. We will define \(\lambda(v_i)\) as the number of bits needed.

However sometimes it is more convienent to refer to the complete value of a
variable at a particular time instance, rather than a particular bit of the
variable over every time instance. We make use of SMT-LIB2's `extract` and
`concat` operators to define a second set of BitVectors that are defined over
the first set. \(\overleftarrow{var_{v,j}}_{[\lambda(v_i)]}\), \(0 \leq j \leq
k+1\) is a vector of \(\lambda(v_i)\) bits that represents the value of variable
\(v_i\) at time instance \(j\).


** Clocks

Each clock \(c \in \mathcal{C}\) is represented by a function \(c\) that takes
an integer argument and returns a real number, where the argument represents the
time position and the return value is the value of the clock at that instance.

* Constraints
TODO: mention that the operators \(\lor, \land, \BitOr , \BitAnd, \Rightarrow\) represent
bvor, bvand, etc. (in background) -  maybe explain how you are exploiting bvlogic to write constraints - quick comment

\begin{center}
\begin{tabular}{c | c | c}
\multicolumn{3}{c}{Initialization and Progression Constraints} \\
\midrule
\(\phi_1 := \underset{i \in [1,|\mathcal{A}|]}{\big\land} \overleftarrow{1}_{[1]} = \overleftarrow{state_{init(i)}}^{[0]}\)
& \(\phi_2 := \underset{v \in Int}{\big\land} \overleftarrow{init(v)} = \overleftarrow{v[0]}\)
& \(\phi_3 := \underset{c \in C}{\big\land} init(c) = c(0)\) \\
\midrule
\(\phi_4 := \underset{i \in [0,k+1]}{\big\land} \delta(i) > 0\) &
\multicolumn{2}{c}{
\(\phi_5 := \overleftarrow{0}_{[k+2]} = \underset{i \in [1,|\mathcal{A}|]}{\big\BitAnd}  \overleftarrow{trans_{i,null}}} \\
\midrule
\multicolumn{3}{c}{
\(\phi_6 := \underset{i \in [1,|\mathcal{A}|]}{\big\land}\ \underset{t \in \mathcal{T}_i}{\big\land} \overleftarrow{trans_t}^{[k:0]} \Rightarrow
\overleftarrow{state_{source(j)}}^{[k:0]}\ \BitAnd\
\overleftarrow{state_{dest(j)}}^{[k+1:1]}\)} \\
\midrule
\multicolumn{3}{c}{
\(\phi_7 := \underset{c \in C}{\big\land}\ \underset{j \in [0,k]}{\big\land}\ \underset{t \in \mathcal{R}(c)}{\BitAnd} (\neg\overleftarrow{t})^{[j]}
\Rightarrow c(j+1) = c(j) + \delta(j)\)} \\
\midrule
\multicolumn{3}{c}{
\(\phi_8 := \underset{v \in Int}{\big\land}  \underset{t \in assign(v)}{\BitAnd} (\neg \overleftarrow{trans_{t}}^{[k:0]}) \Rightarrow \underset{j \in [1,\lambda(v)]}{\big\BitAnd}
(tb_j^{[k:0]} = tb_j^{[k+1:1]}) \)} \\
\end{tabular}
\end{center}
** Initialization & Progression

The initialization constraints are similar for states, clocks, and bounded
variables. For states, we assert that the initial state holds in the first time
instance by comparing the vector for the initial state \(state_{i,init}\) to the
constant vector \(\overleftarrow{1}_{[1]}\) in formula \(\phi_1\). This requires
the first bit of the state vector to be set to 1, signifying that the state is
active in time instance 0. For variables, we assert that the provided intial
starting value, \(init(v)\) is equal to the value of the variable at time
instance 0. For clocks, we assert that the clock function at time instance 0 is
equal to its provided initial value in formula \(\phi_3\).

Each time instance in the range \([0,k+1]\) represents an instant of time in
which at least one timed automaton makes a discrete (non-null) transition. In
between these instances, all timed automata remain stationary, and only the
clocks progress. To capture this progression, we introduce a new clock,
\(\delta\). Formula \(\phi_4\) captures that \(\delta\) is defined as a function
over integers in the range \([0,k+1]\) that returns positive integers. The value
of \(delta(i)\) at instance \(i\) refers to the amount of time between instance
\(i\) and instance \(i+1\). To ensure that each time instance contains a
discrete transition, we assert with formula \(\phi_5\) that at every instance,
at least one timed automaton \(i\) has \(\overleftarrow{trans_{i,null}}\) set to
0, meaning that it is not taking a null transition. This guarantees that at
least one timed automaton has an active non-null transition at each time
instance. Another aspect of progression is ensuring that the active state of a
timed automaton correctly reflects the transitions being taken. To that effect,
formula \(\phi_6\) asserts that when a transition is taken at time instance
\(i\), the source state of the transition is active at instance \(i\), and the
destination state is active at instance \(i+1\).

We must next discuss the progession of the clocks and integer variables. In
formula \(\phi_4\) we discussed the special clock \(\delta\), and how it
represents the passing of time between the discete time instances. Formula
\(\phi_7\) connects \(\delta\) to the other clocks. At each time instance \(i\),
a clock is either reset by a transition, or its value increments by
\(\delta(i)\). To do this we define the set \(\mathcal{R}_c\) for every clock
\(c\), which is defined as the set of all transitions \(t\) that reset the value
of clock \(c\). When no transition in \(\mathcal{R}_c\) is active, the clock
must progress according to the value of \(\delta\). Similarly for variables, we
define the set \(assign(v)\) for every variable \(v\) containing all transitions
that assign a value to the variable. When none of these transitions are active,
formula \(\phi_8\) ensures that the value of \(v\) remains unchanged.

** Transitions

\begin{center}
\begin{tabular}{c}
Transition Constraints \\
\midrule
\(\phi_9 := \underset{t \in T}{\big\land}\ \underset{\gamma \in TODO_t}{\big\land}\ \underset{l \in [0,k]}{\big\land} \overleftarrow{trans_t}^{[l]} \Rightarrow  (c_\gamma(l) + \delta(l))\ \sim_\gamma\
val_\gamma\) \\
\midrule
\(\phi_{10} := \underset{t \in T}{\big\land}\ \underset{\gamma \in TODO_t}{\big\land}\ \underset{l \in [0,k]}{\big\land} \overleftarrow{trans_t}^{[l]} \Rightarrow  \overleftarrow{var_\gamma(l)}\ \sim_\gamma\ \overleftarrow{val_\gamma}\) \\
\midrule
\(\phi_{11} := \underset{t \in T}{\big\land}\ \underset{\alpha \in TODO_t}{\big\land}\ \underset{l \in [0,k]}{\big\land} \overleftarrow{trans_t}^{[l]} \Rightarrow c_\alpha(l+1) = val_\alpha\) \\
\midrule
\(\phi_{12} := \underset{t \in T}{\big\land}\ \underset{\alpha \in TODO_t}{\big\land}\ \underset{l \in [0,k]}{\big\land} \overleftarrow{trans_t}^{[l]} \Rightarrow \overleftarrow{var_\alpha(l+1)} = expr_\alpha\) \\
\midrule
\(\phi_{13} := \underset{t \in T}{\big\land} \overleftarrow{trans_t} \Rightarrow (v \vDash Inv(source(t)) \land v' \vDash_w Inv(dest(t))) \)\( \lor (v \vDash_w Int(source(t)) \land v' \vDash Inv(dest(t)))\) \\
\bottomrule
\end{tabular}
\end{center}

Each transition can have multiple guards. The guards consist of two types, clock
guards and variable guards. We will consider clock guards first. Clock guards
have the form \(c\ \sim\ val\), where \(c \in \mathcal{C}\), \(val \in
\mathbb{Z}\) and \(\sim \in \{<,>,\leq,\geq\}\). Formula \(\phi_9\) asserts that
for every clock guard, its transition being active at time instance \(l\)
implies that at the instance of transition, the relationship \(\sim\) holds
between the clock value (which is incremented by \(\delta(l)\) to account for
the amount of time spent in the state \(source(t)\)) and the value \(val\).
\(\phi_{10}\) captures the same semantics for variable guards, asserting that an
active transition with a guard implies that the guard is true at that time
instance.

** Sync
\begin{center}
\begin{tabular}{c}
Sync Constraints \\
\(\phi_{14} := \underset{\alpha \in Act}{\land} \underset{t \in SEND(\alpha)}{\land} \overleftarrow{trans_t} \Rightarrow (\neg \underset{t' \in SEND(\alpha)}{\lor} \overleftarrow{trans_{t'}}) \land (\underset{t' \in REC(\alpha)}{\lor} \overleftarrow{trans_{t'}})\) \\
\midrule
\(\phi_{15} := \underset{\alpha \in Act}{\land} \underset{t \in REC(\alpha)}{\land} \overleftarrow{trans_t} \Rightarrow (\neg \underset{t' \in REC(\alpha)}{\lor} \overleftarrow{trans_{t'}}) \land (\underset{t' \in SEND(\alpha)}{\lor} \overleftarrow{trans_{t'}})\) \\
\end{tabular}
\end{center}
** Loop Constraints

\begin{center}
\begin{tabular}{c}
Loop Constraints \\
\(\phi := \underset{i \in [1,|\mathcal{A}|}{\big\land}\ \underset{j \in [1,\lceil\log_2 |\mathcal{T}_i|\rceil]}{\big\land} \overleftarrow{tb_j}^{[k+1]} = \overleftarrow{tb_j}^{[loop]}\) \\
\midrule
\(\phi := \underset{v \in Int}{\big\land}\ \underset{j \in [1,\lambda(v)]}{\big\land} \overleftarrow{vb_j}^{[k+1]} = \overleftarrow{vb_j}^{[loop]}\) \\
\midrule
\(\phi := \underset{c \in X}{\big\land} (\lfloor c(k+1) \rfloor\ = \lfloor c(loop) \rfloor) \lor (\lfloor c(k+1) \rfloor\ > max(c) \land \lfloor c(loop) \rfloor > max(c)) \) \\
\midrule
\(\phi := \underset{c \in X}{\big\land} \lfloor c(loop) \rfloor < max(c) \Rightarrow (frac(c(k+1)) = 0) \Leftrightarrow (frac(c(loop)) = 0) \\
\midrule
\(\phi := \underset{c,c' \in X}{\big\land} frac(c(k+1)) < frac(c'(k+1)) \Leftrightarrow frac(c(loop)) < frac(c'(loop)) \\
\midrule
\(\phi := \underset{c \in X}{\land} c(k) > c(max) \lor (TODO resetInLoop)\) \\
\end{tabular}
\end{center}

As mentioned previously, we are only interested in lasso-shaped runs that end in
a loop. To keep track of the initial position of the loop, we declare the
variable \(loop_init\), and constrain it to have a value in the range \([1,k]\).

Intuitively, the time position \(k+1\) represents the first time position in the
next iteration of the loop. It is effectively a 'copy' of the position
\(loop_init\), however we add it as a distinct position so that we may capture
the semantics of the transition between time position \(k\) and time position
\(loop_init\). We therefore introduce constraints [], which require that the
active state and transition of each timed automata at instance \(k+1\) be equal
to that at instance \(loop_init\). The set of constraints [] enforces the same
requirement for each bounded integer variable.

Naively we would enforce the same constraint on every clock, however [reference
Kinderman paper]. Therefore for each clock
