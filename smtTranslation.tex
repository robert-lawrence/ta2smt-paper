% Created 2020-08-20 gio 13:13
% Intended LaTeX compiler: pdflatex
\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[margin=1in]{geometry}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{setspace}
\newcommand*\BitAnd{\mathbin{\&}}
\newcommand*\BitOr{\mathbin{|}}
\newcommand*\ShiftLeft{\ll}
\newcommand*\ShiftRight{\gg}
\renewcommand{\arraystretch}{1.0}
\setlength{\parskip}{1em}
\setlength{\abovetopsep}{0.5em}
\renewcommand{\baselinestretch}{1.3}
\author{Robert Smith}
\date{\today}
\title{SMT Translation}
\begin{document}

\maketitle
\tableofcontents

\section{Introduction}\label{introduction}
\iffalse
Timed Automata are a commonly used representation for modeling the behavior of
systems with real-time semantics.

Bounded Satisfiability Checking is a process in which timed automata can be
verified against a property. The TA system along with the desired property are
converted into a format suitable for parsing by a SAT or SMT solver. Then the
solver is tasked with finding a counterexample to the property. Since TA traces
are infinite in length, we restrict ourselves to traces of the form
\(s_1 s_2,\ldots s_{l-1}{(s_l s_{l+1}\ldots s_{n-1}s_n)}^\omega\). These
lasso-shaped traces consist of an initial sequence of states up until
\(s_{l-1}\), followed by a loop that can be repeated an infinite amount of
times to form the full trace. Since the beginning of the loop is allowed to
occur anywhere within the sequence, the only variable is the number of distinct
states \(n\). Bounded Satisfiability Checking refers to checking if a given
property is satisfied over lasso-shaped traces of up to length \(n\).

Current examples of TA bounded model checkers include XX, YY, and de facto
standard Uppaal. TACK is a tool focused on allowing for the expression of TA
properties in Metric Interval Temporal Logic, a rich \ldots{}

TACK translates both the TA and the property to be verified into CLTLoc.
Constraint Linear Temporal Logic (over clocks) is a variant of

Zot

Sbvzot is a very successful solver which takes advantage of bit vector logic\ldots{}

To further improve the performance of TACK, we wish to directly translate the
network of timed automata into the SMT-LIB format, skipping the intermediate
CLTLoc representation. While CLTLoc is an elegant expressive language, there is
a significant overhead in
\fi
\section{Preliminaries}\label{prelims}
\subsection{Bit-Vector Logic}\label{bvlogic}
A BitVector is an array of binary values, or bits. BitVectors are interpreted
using two's complement arithmetic to produce integer values, and their length
can be any positive integer (\(\mathbb{Z}^+\)). We use the notation
\(\overleftarrow{x}_{[n]}\) to represent a BitVector \(x\) of length \(n\), but
this can be simplified to \(\overleftarrow{x}\) if the length is clear. Bits are
numbered from right to left, with the rightmost, least significant bit labeled
as 0, and the leftmost, most significant bit labeled as \(n-1\). As an example,
the constant vector \(-4\) of length 5 would be written as
\(\overleftarrow{-4}_{[5]}\), which would expand to \(11100\). We can also
reference individual bits in the vector using the notation
\(\overleftarrow{x}_{[n]}^{[i]}\) to \(extract\) the \(i\)th bit from the
BitVector \(x\). It is also possible to extract a sub-vector with the notation
\(\overleftarrow{x}_{[n]}^{[j:i]}\), where \(n>j\geq i\geq 0\). This extracts a
vector of length \(j-i+1\) whose rightmost bit corresponds to the \(i\)th bit of
\(x\) and whose leftmost bit corresponds to the \(j\)th. Similarly,
\(concatenation\) operates on two BitVectors by combining their bit arrays.
\(\overleftarrow{x}_{[n]} :: \overleftarrow{y}_{[m]}\) returns a new BitVector
\(\overleftarrow{z}_{[n+m]}\) where \(\overleftarrow{z}^{[m-1:0]} =
\overleftarrow{y}\), and \(\overleftarrow{z}^{[m+n-1:m]} = \overleftarrow{x}\).

The usual arithmetic operations of addition \(+\) and subtraction \(-\) are
defined over two BitVectors of the same length. BitVectors also support the
bit-wise operators not \(\neg\), disjuction \(\lor\), conjunction \(\land\),
equivalence \(\iff\), and implication \(\Rightarrow\). These binary operators return a
new BitVector where each bit \(i\) is the result of applying the logical
operator to the \(i\)th bit of each of the input vectors, following the usual
convention where \(1\) is true and \(0\) is false.

\subsection{Timed Automata}\label{timed-automata}
Let \(AP\) be a set of atomic propositions, and let \(Act\) be a set of
synchronization events. In addition we define a null event \(\tau\).
\(Act_{\tau}\) is the set \(Act \cup \{\tau\}\). Let \(X\) be a finite set of
clocks, and \(Int\) a finite set of integer-valued variables. \(\Gamma(X)\) is
the set of clock constraints, where a clock constraint \(\gamma\) is a relation
\(x \sim c \BitOr \neg \gamma\BitOr \gamma \land \gamma\), where \(x \in X\),
\(\sim \in \{<,=\}\), and \(c \in \mathbb{N}\). \(Assign(X)\) is the set of
clock assignments, where each assignment has the form \(x = c\), where \(x {\in}
X,\ c {\in} \mathbb{Z}^+\). \(Assign(Int)\) is a set of variable assignments of
the form \(y := exp\), where \(exp := exp + exp\BitOr exp - exp\BitOr exp \times
exp\BitOr exp \div exp\BitOr n\BitOr c\), \(y \in Int\) and \(c \in
\mathbb{Z}\). \(\Gamma(Int)\) is the set of integer variable constraints, where
a variable constraint \(\gamma\) is defined as \(\gamma := n \sim c\BitOr n \sim
n'\BitOr \neg \gamma\BitOr \gamma \land \gamma\), where \(n\) and \(n'\) are
integer variables, \(c \in \mathbb{Z}\), and \(\sim \in \{<,=\}\). A Timed
Automaton with variables is defined as the tuple \(\mathcal{A} = <AP,X,
Act_{\tau}, Int, Q, q_0, v_{var}^0, Inv, L, T>\). \(Q\) is the finite set of
states of the timed automaton, and \(q_0 \in Q\) is the initial state. \(Inv : Q
\rightarrow \Gamma(X)\) is a function assigning each state to a (possibly empty)
set of clock constraints. The labeling function \(L: Q \rightarrow
\mathcal{P}(AP)\) assigns each state to a subset of the atomic propositions.
Each transition \(t \in T\) has the form \(T \subset Q \times Q \times
Act_{\tau} \times \Gamma(X) \times \Gamma(Int) \times \mathcal{P}(Assign(X))
\times \mathcal{P}(Assign(Int))\), consisting of a source and destination state,
an action, a set of clock and variable guards, and a set of clocks to be reset
when the transition fires. To refer to the components of a transition we will
use \(t_-\) and \(t_+\) to refer to the source and destination states
respectively, as well as \(t_\epsilon, t_{\gamma_c}, t_{\gamma_v}, t_{a_c},
t_{a_v}\) to refer to the event, clock constraints, variable constraints, clock
assignments, and variable assignments respectively.

A network of Timed Automata is a finite list of timed automata \(\mathcal{A} =
[\mathcal{A}_1, \mathcal{A}_2, \ldots \mathcal{A}_k]\). Timed Automata in the
same network can refer to common clocks, variables, and synchronization channels
to coordinate their actions. To simplify the notation we will use the symbols
\(T\), \(X\), \(Int\), and \(Act/Act_t\) to refer to the union of the respective
sets of each individual timed automaton in the network. When necessary to refer
to the properties of one timed automaton in particular, we will append a
numerical subscript to the set in question, for example \(X_i\) to refer to the
clocks used by a specific timed automaton.

\subsection{Bounded Satisfiability Checking}\label{bounded-sat}

(here sketch both ta->CLTLoc encoding and sbvzot translation)

\subsection{TACK CLTLoc Translation}\label{prelim-tack}

\begin{table}\label{tack-encoding}
  \centering
  % \setlength{\tabcolsep}{4pt}
  \aboverulesep=0ex
  \belowrulesep=0ex
  \renewcommand{\arraystretch}{1.2}
  \caption{TACK Encoding of an Automaton in CLTLoc}
  \begin{tabular}{c|c|c}
    \toprule
    \(\varphi := \underset{k \in [1,K]}{\bigwedge} (l[k] = 0)\) &
                                                                 \(\varphi := \underset{n \in Int}{\bigwedge} n = v_{var}^0 (n) \) &
                                                                                                                                     \(\varphi := \underset{k \in [1,K]}{\bigwedge} Inv(l[k])\) \\
    \midrule
    \(\varphi\)
  \end{tabular}
\end{table}

The TACK tool developed by Menghi converts Bounded Satisfiability Checking
problems into the CLTLoc language. TACK uses Metric Interval Temporal Logic to
specify the property to be checked for satisfiabilty. The choice of MITL allows
for more elegant and powerful specifications of the desired properties to be
checked. Once the Timed Automata network and the MITL property have been
converted into CLTLoc, TACK then uses the tool Zot to convert this intermediate
represetation of the problem into the SMT-LIB2 language, which is supported by
many modern SMT solvers. Zot was designed with a modular architecture to allow
for several different strategies and algorithms that can be used to convert its
input. Currently the most successful Zot plugin for CLTLoc Bounded Model
Checking is ae2sbvzot. We will provide an overview of both the TACK encoding of
Timed Automata in CLTLoc and the ae2sbvzot translation of CLTLoc into SMT-LIB2.

\ref{tack-encoding} contains the formulas used to encode the Timed Automata into
CLTLoc. The first formula constrains each TA to be in the initial state at time
0. Here the function \(l\) accepts an index in \([1,K]\), where
\(K = |\mathcal{A}|\). For each Timed Automaton, the states are represented as
natural numbers, with the initial state as \(0\). The second formula initializes
each variable \(n \in Int\) to its initial value, and the third ensures that the
invariants of each initial state hold in the initial position. Note that there
is no explicit clock initialization, since in CLTLoc all clocks have a value of
\(0\) at time \(0\).

\section{TA Encoding}\label{encoding}

Using BitVector logic, we have the ability to group logically connected
propositions into a Vector, granting significant speedups on operations
performed over every element of the vector. We wish to use this property to
group together logically connected constraints of the encoding. One common
source of constraint duplication is the transition constraints. These
constraints enforce the semantics of Timed Automaton transitions, requiring
that, for example all guards and assignment statements have been fulfilled.
These constraints must be upheld at every transition in the trace, which can be
dozens of discrete transitions long. This motivates us to use the BitVectors to
represent a piece of information changing over time, i.e.\ representing its value
at different time instances in the trace.

When encoding the constraints of the system, it is convenient to write that a
constraint will hold over every discrete time position in the trace. As an
example, consider a transition with an assignment \(var_i = 5\). When
formalizing the constraints, it would be simpler to have a formula of the type
\(\overleftarrow{transition}_{[k+2]} \rightarrow
\overleftarrow{assignment}_{[k+2]}\) that we can assert over every time position
at once. In this model we are using BitVectors of length \(k+2\) where each
position in the BitVector represents the formula at a different moment in time.
This allows us to use the BitVector implication operator to assert that the
transition BitVector implies a given constraint at every time instance. At a
given time instance \(i\), if the corresponding bit in the transition BitVector
is set to 1, then the same bit in the variable BitVector would be required to be
set to 1 as well. Otherwise the SMT solver would dismiss the trace as invalid.

This encoding, while convenient, is not very efficient. Using one BitVector per
each transition yields a space complexity of \(O(|T|k)\). Since only one
transition is active at a time, it is more compact to store the currently active
transition as a binary number over \(\lceil\log_2 |T|\rceil\) bits, where \(T\)
is the set of transitions. Therefore we will create \(\lceil\log_2 |T|\rceil\)
BitVectors of length \(k+2\) to represent the active transition of the TA over
time. In order to be able to conveniently refer to individual elements of the
set, we will define aliases which refer to unique combinations of the
BitVectors. This will give us the convenience of the individually-named BitVectors
while retaining the efficiency of the compact approach. This method will be
formalized below for the encoding of the states, transitions, and variables of
the Timed Automata.

For a model with a time bound of k, and a timed automaton with n distinct
transitions, we represent the active transition of the automaton at different
time instances as follows:

\begin{table}
\centering
\begin{tabular}{ll}
 & k+1, \(\ldots\), 1, 0\\
\midrule
0 & \(\overleftarrow{sb_{i,0}}_{[k+2]}\)\\
1 & \(\overleftarrow{sb_{i,1}}_{[k+2]}\)\\
\ldots{} & \ldots{}\\
\(\lceil \log_2 n_i \rceil -1\) & \(\overleftarrow{sb_{i, \lceil \log_2 n_i \rceil -1}}_{[k+2]}\)\\
\end{tabular}
\end{table}

After defining the BitVectors to store the bits of the active transition, we
define aliases for the \(|T|\) transitions as shown in table \ref{t-aliases}.
Transition 0 is simply defined as the bit-wise `and' of the negations of each of
the \(sb\) BitVectors. Transition 1 differs in that the last BitVector is not
negated. This corresponds to the BitVector representation of the number 1, which
is \(\overleftarrow{00\ldots 001}\). When viewed in the table, the pattern becomes more clear. Each
transition is encoded as a unique combination of the \(sb\) vectors. Because
the exact value of \(|T|\) is unknown, for the last transition in the table we
use the symbol \(\sim\) to signal that whether or not the BitVector is negated
depends on the exact value of \(|T|\).

\begin{table}
\centering
\caption{Construction of the Transition Aliases}
\begin{tabular}{c | c}\label{t-aliases}
Transition & Alias \\
\midrule
\(T_{i,0}\) & \(\neg\overleftarrow{sb_{i,\lceil \log_2 n_i \rceil -1}} \BitAnd \neg\overleftarrow{sb_{i,\lceil \log_2 n_i \rceil -2}} \BitAnd \ldots \BitAnd \neg\overleftarrow{sb_{i,1}} \BitAnd \neg\overleftarrow{sb_{i,0}} \) \\
\(T_{i,1}\) & \(\neg\overleftarrow{sb_{i,\lceil \log_2 n_i \rceil -1}} \BitAnd \neg\overleftarrow{sb_{i,\lceil \log_2 n_i \rceil -2}} \BitAnd \ldots \BitAnd \neg\overleftarrow{sb_{i,1}} \BitAnd \overleftarrow{sb_{i,0}} \) \\
\(T_{i,2}\) & \(\neg\overleftarrow{sb_{i,\lceil \log_2 n_i \rceil -1}} \BitAnd \neg\overleftarrow{sb_{i,\lceil \log_2 n_i \rceil -2}} \BitAnd \ldots \BitAnd \overleftarrow{sb_{i,1}} \BitAnd \neg\overleftarrow{sb_{i,0}} \) \\
\rotatebox{90}{\(\ldots\)} & \rotatebox{90}{\(\ldots\)} \\
\(T_{i,|T|}\) & \(\overleftarrow{sb_{i,\lceil \log_2 n_i \rceil -1}} \BitAnd (\sim\overleftarrow{sb_{i,\lceil \log_2 n_i \rceil -2}}) \BitAnd \ldots \BitAnd (\sim\overleftarrow{sb_{i,1}}) \BitAnd (\sim\overleftarrow{sb_{i,0}}) \) \\

\end{tabular}
\end{table}


\subsection{Transitions}\label{encoding-transitions}

In the traditional description of Timed Automata, a TA that does not perform a
discrete transition at a given time instance is said to perform a \(null\
transition\), i.e.\ staying in the same state without firing any transition in
the set \(T\). In our encoding it is convenient to explicitly add a null
transition for each state \(q \in Q\) to the set of transitions. \(\forall_{q
\in Q} trans_{null_q} := {<}q, q, \tau, \varnothing, \varnothing, \varnothing,
\varnothing {>}\), and \(\mathcal{T} = T \cup \{\cup_{q \in Q}
trans_{null_q}\}\) \(trans_{null} := \BitOr_{q \in Q} trans_{null_q}\)

We define \(O: \mathcal{T} \rightarrow \mathbb{N}\) be a bijective
function mapping each transition to a natural number less than
\(|\mathcal{T}|\). We define BitVectors \(\{\overleftarrow{tb_1},
\overleftarrow{tb_2}, \ldots, \overleftarrow{tb_{\lceil
\log_2 |\mathcal{T}|\rceil}}\}\) of size \(k+2\). The BitVector for each
individual transition is defined as \(\overleftarrow{trans_t}_{[k+2]} :=
\BitAnd_{i=1}^{\lceil\log_2 |\mathcal{T}|\rceil} N_t(tb_i)\), where \(N_t(tb_i)\)
returns \(tb_i\) if the \(i\)th bit in the base two representation of \(O(t)\)
is 1, and returns \(\neg tb_i\) otherwise.

For clarity, let us consider an example TA with
\(\lceil\log_2 |\mathcal{T}|\rceil = 5\) and a transition \(t \in \mathcal{T}\)
with \(O(t) = 5\). The base two representation of 5 is \(00101\), and therefore
\(\overleftarrow{trans_t}_{[k+2]}\) is equivalent to \((\neg tb_5 \BitAnd
\neg tb_4 \BitAnd tb_3 \BitAnd \neg tb_2 \BitAnd tb_1)\).

\subsection{States}\label{encoding-states}

For each TA \(\mathcal{A}_l \in \mathcal{A}\), we define a BitVector to
represent each state of the timed automaton. To do this we define each state as
the disjunction of all the transitions whose source is that state.

\[state_s := \BitOr\{trans_t : source(t) = s\}\ \ \forall_{s \in S}\]

For each TA \(\mathcal{A}_l \in \mathcal{A}\), let \(O: Q \rightarrow
\mathbb{N}\) be a bijective function mapping each state to a natural number less
than \(|Q|\). We define BitVectors \(\{\overleftarrow{sb_1},
\overleftarrow{sb_2}, \ldots, \overleftarrow{sb_{\lceil\log_2 |Q|\rceil}}\}\),
each of length \(k+2\). The BitVector for the individual state is then defined
as \(\overleftarrow{state_q}_{[k+2]} := \BitAnd_{i=1}^{\lceil\log_2 |Q|\rceil}
N_q(sb_i)\), where \(N_q(sb_i)\) returns \(sb_i\) if the \(i\)th bit in the base
two representation of \(O(q)\) is 1, and returns \(\neg sb_i\) otherwise.

\subsection{Variables}\label{encoding-variables}

Bounded integer variables are treated slightly differently, because unlike
states and transitions, the possible values of a bounded integer variable are
not unrelated objects in a set, but integers that must respect the operations of
addition and subtraction. For each variable \(v_i \in Int\) we still construct a
bit representation \(\overleftarrow{vb_{i,j}}_{[k+2]}\), where each BitVector
has length \(k+2\). However the difference is that the values are encoded in 2s
complement notation, and the number of BitVectors is chosen so that the vectors
are capable of representing the entire range of values for the given bounded
integer variable. We will define \(\lambda(v_i)\) as the number of bits needed.

However sometimes it is more convenient to refer to the complete value of a
variable at a particular time instance, rather than a particular bit of the
variable over every time instance. We make use of SMT-LIB2's `extract' and
`concat' operators to define a second set of BitVectors that are defined over
the first set. \(\overleftarrow{var_{v,j}}_{[\lambda(v_i)]}\), \(0 \leq j \leq
k+1\) is a vector of \(\lambda(v_i)\) bits that represents the value of variable
\(v_i\) at time instance \(j\).


\subsection{Clocks}\label{encoding-clocks}

Each clock \(c \in \mathcal{C}\) is represented by a function \(c\) that takes
an integer argument and returns a real number, where the argument represents the
time position and the return value is the value of the clock at that instance.

\section{Constraints}\label{constraints}
\iffalse
TODO:\@ mention that the operators \(\lor, \land, \BitOr , \BitAnd, \Rightarrow\) represent
bvor, bvand, etc. (in background) -  maybe explain how you are exploiting
bvlogic to write constraints - quick comment
\fi

\subsection{Initialization \& Progression}\label{constraints-init}

\begin{table}
\begin{tabular}{c | c | c}
\multicolumn{3}{c}{Initialization and Progression Constraints} \\
\midrule
\(\phi_1 := \underset{i \in [1,|\mathcal{A}|]}{\bigwedge} \overleftarrow{1}_{[1]} = \overleftarrow{state_{init(i)}}^{[0]}\)
& \(\phi_2 := \underset{v \in Int}{\bigwedge} \overleftarrow{init(v)} = \overleftarrow{v[0]}\)
& \(\phi_3 := \underset{c \in C}{\bigwedge} init(c) = c(0)\) \\
\midrule
\(\phi_4 := \underset{i \in [0,k+1]}{\bigwedge} \delta(i) > 0\) &
\multicolumn{2}{c}{
\(\phi_5 := \overleftarrow{0}_{[k+2]} = \underset{i \in [1,|\mathcal{A}|]}{\BitAnd}  \overleftarrow{trans_{null_i}} \)} \\
\midrule
\multicolumn{3}{c}{
\(\phi_6 := \underset{t \in \mathcal{T}}{\bigwedge} \overleftarrow{trans_t}^{[k:0]} \Rightarrow
\overleftarrow{state_{t_-}}^{[k:0]}\ \BitAnd\
\overleftarrow{state_{t_+}}^{[k+1:1]}\)} \\
\midrule
\multicolumn{3}{c}{
\(\phi_7 := \underset{c \in C}{\bigwedge}\ \underset{j \in [0,k]}{\bigwedge}\ \underset{t \in \mathcal{R}(c)}{\BitAnd} {(\neg\overleftarrow{t})}^{[j]}
\Rightarrow c(j+1) = c(j) + \delta(j)\)} \\
\midrule
\multicolumn{3}{c}{
\(\phi_8 := \underset{v \in Int}{\bigwedge}  \underset{t \in assign(v)}{\BitAnd} (\neg \overleftarrow{trans_{t}}^{[k:0]}) \Rightarrow \underset{j \in [1,\lambda(v)]}{\BitAnd}
(tb_j^{[k:0]} = tb_j^{[k+1:1]}) \)} \\
\end{tabular}
\end{table}

The initialization constraints are similar for states, clocks, and bounded
variables. For states, we assert that the initial state holds in the first time
instance by comparing the vector for the initial state \(state_{init(i)}\) to the
constant vector \(\overleftarrow{1}_{[1]}\) in formula \(\phi_1\). This requires
the first bit of the state vector to be set to 1, signifying that the state is
active in time instance 0. For variables, we assert that the provided initial
starting value, \(init(v)\) is equal to the value of the variable at time
instance 0. For clocks, we assert that the clock function at time instance 0 is
equal to its provided initial value in formula \(\phi_3\).

Each time instance in the range \([0,k+1]\) represents an instant of time in
which at least one timed automaton makes a discrete (non-null) transition. In
between these instances, all timed automata remain stationary, and only the
clocks progress. To capture this progression, we introduce a new clock,
\(\delta\). Formula \(\phi_4\) captures that \(\delta\) is defined as a function
over integers in the range \([0,k+1]\) that returns positive integers. The value
of \(delta(i)\) at instance \(i\) refers to the amount of time between instance
\(i\) and instance \(i+1\). To ensure that each time instance contains a
discrete transition, we assert with formula \(\phi_5\) that at every instance,
at least one timed automaton \(i\) has \(\overleftarrow{trans_{null_i}}\) set to
0, meaning that it is not taking a null transition. This guarantees that at
least one timed automaton has an active non-null transition at each time
instance. Another aspect of progression is ensuring that the active state of a
timed automaton correctly reflects the transitions being taken. To that effect,
formula \(\phi_6\) asserts that when a transition is taken at time instance
\(i\), the source state of the transition is active at instance \(i\), and the
destination state is active at instance \(i+1\).

We must next discuss the progression of the clocks and integer variables. In
formula \(\phi_4\) we discussed the special clock \(\delta\), and how it
represents the passing of time between the discrete time instances. Formula
\(\phi_7\) connects \(\delta\) to the other clocks. At each time instance \(i\),
a clock is either reset by a transition, or its value increments by
\(\delta(i)\). To do this we define the set \(\mathcal{R}_c\) for every clock
\(c\), which is defined as the set of all transitions \(t\) that reset the value
of clock \(c\). When no transition in \(\mathcal{R}_c\) is active, the clock
must progress according to the value of \(\delta\). Similarly for variables, we
define the set \(assign(v)\) for every variable \(v\) containing all transitions
that assign a value to the variable. When none of these transitions are active,
formula \(\phi_8\) ensures that the value of \(v\) remains unchanged.

\subsection{Transitions}\label{consstraints-trans}

\begin{center}
\begin{tabular}{c}
Transition Constraints \\
\midrule
\(\vDash \quad := \sigma_c(l) + d \vDash \Gamma(X) \iff \underset{c,\sim,val \in \Gamma(X)}{\bigwedge} c(l) + d \sim val \) \\
\midrule
\(\vDash \quad := \sigma_v(l) \vDash \Gamma(X) \iff \underset{v,\sim,val \in \Gamma(X)}{\bigwedge} \overleftarrow{var_v(l)} \sim \overleftarrow{val} \) \\
\midrule
\(\vDash_w \quad := \sigma_c(l) + d \vDash_w \Gamma(X) \iff \underset{c,\sim,val \in \Gamma(X)}{\bigwedge} c(l) + d \sim_w val \) \\
\midrule
\(\phi_9 := \underset{t \in T}{\bigwedge}\ \underset{l \in [0,k]}{\bigwedge} \overleftarrow{trans_t}^{[l]} \Rightarrow  \sigma_c(l) + \delta(l) \vDash t_{\gamma_c} \) \\
\midrule
\(\phi_{10} := \underset{t \in T}{\bigwedge}\ \underset{l \in [0,k]}{\bigwedge} \overleftarrow{trans_t}^{[l]} \Rightarrow  \sigma_v(l) \vDash t_{\gamma_v} \) \\
\midrule
\(\phi_{11} := \underset{t \in T}{\bigwedge}\ \underset{c,val \in t_{a_c}}{\bigwedge}\ \underset{l \in [0,k]}{\bigwedge} \overleftarrow{trans_t}^{[l]} \Rightarrow c(l{+}1) = val\) \\
\midrule
\(\phi_{12} := \underset{t \in T}{\bigwedge}\ \underset{v,expr \in t_{a_v}}{\bigwedge}\ \underset{l \in [0,k]}{\bigwedge} \overleftarrow{trans_t}^{[l]} \Rightarrow \overleftarrow{var(l{+}1)} = \overleftarrow{expr(l{+}1)} \) \\
\midrule
\(\phi_{13} := \underset{t \in T}{\bigwedge} \overleftarrow{trans_t}^{[l]} \Rightarrow \biggl(\sigma_c(l) \vDash Inv(t_-) \land \sigma_c(l{+}1) \vDash_w Inv(t_+)\biggr) \)\( \lor \biggl(\sigma_c(l) \vDash_w Int(t_-) \land \sigma_c(l{+}1) \vDash Inv(t_+)\biggr)\) \\
\bottomrule
\end{tabular}
\end{center}

As a quick review, transitions consist of a source and destination state, a
synchronization action, as well as (possibly empty) sets of clock constraints,
variable constraints, clock assignments, and variable assignments. In the
earlier chapter on initialization and progression, \(\phi_6\) was defined to
ensure that the source and destination states were implemented correctly - that
the destination of one transition is the source of the next.


We will first consider the transition guards. Each transition can have multiple
guards, which consist of two types, clock guards and variable guards. Clock
guards have the form \(c\ \sim\ val\), where \(c \in X\), \(val \in
\mathbb{Z}\) and \(\sim \in \{<,>,\leq,\geq\}\). Formula \(\phi_9\) asserts that
for every clock guard, its transition being active at time instance \(l\)
implies that at the instance of transition, the relationship \(\sim\) holds
between the clock value and the value. Recall that if a transition is active at
time instance \(l\), the transition occurs in the instant between time instance
\(l\) and time instance \(l+1\). Therefore, at the instance of the transition,
the clock does not have the value \(c(l)\), but rather \(c(l) + \delta(l)\),
delta being the special clock that defines the amount of time spent in each time
instance. Note that we cannot simply use \(c(l+1)\) as the value of the clock,
because it is possible that during the transition between time instance \(l\)
and \(l+1\), the value of the clock may be reset, which would set \(c(l+1)=0\).
Our guard only sees the pre-transition value of the clock, and thus we must
manually add \(\delta(l)\) to the value.
\(\phi_{10}\) captures the same semantics for variable guards, asserting that an
active transition with a guard implies that the guard is true at that time
instance. Because variables, unlike clocks, do not progress with time, it is
sufficient to simply use the value \(var(l)\) to determine if the guard is satisfied.

Clock assignments are more straightforward then the clock guards. It is enough
to require that if a transition is taken at time instance \(l\), then in the
following time instance the clock is reset to the desired value. Variable
assignments however, are more complex. Unlike clock assignments, which reset
clocks to a constant number in \(\mathbb{Z}^+\), variable assignments can access
both constant values and the values of other variables, and they may combine
them using the operators \(\{+,-\}\). To implement this in our bvlogic, we first
require that if a variable \(v'\) appears in the assignment expression of
variable \(v\), then the possible values of \(v'\) must be a subset of the
possible values of \(v\). Recall that \(\overleftarrow{var_v}(l)\) is a bit
vector of \(\lambda(v)\) bits that contains the value of \(v\) at time instance
\(l\) in two's-complement form. By constraining \(v' \subseteq v\), we prevent
\(v'\) from having a BitVector of greater length than that of \(v\). We can then
cast all constants and variables to BitVectors of length \(\lambda(v)\),
sign-extending shorter variables if necessary. This allows us to use the
standard BitVector addition and subtraction operators to compute the final
value, which is assigned to \(v\) at time instance \(l{+}1\).

The last component of a transition to discuss is the state invariant. Although
invariants are state-specific, not transition-specific, since states are defined
by the active transitions, it is sufficient to ensure that a transition never
leads to a state whose invariant would be unsatisfied. \(\phi_{13}\)
accomplishes this using the notions of strong and weak satisfaction. Explained
in the original TACK paper, weak satisfaction is a relation where the invariants
are relaxed so that the relations \(<,>\) are also satisfied with equality. This
was done to model the fact that at the instant of transition, the transition is
located in exactly one of the two states, source or destination. This choice can
be different for each timed automaton and each time instance. If the timed
automaton is not in a state in the instance of transition, then a strict
inequality can be satisfied with equality at the instance of transition, since
the automaton is not actually in that state at that instant.

\subsection{Sync}\label{constraints-sync}
\begin{center}
\begin{tabular}{c}
Sync Constraints \\
\(\phi_{14} := \underset{t \in T: t_\epsilon = \alpha!}{\bigwedge} \overleftarrow{trans_t} \Rightarrow (\neg \underset{t' \in T: t'_\epsilon = \alpha!\land t'\neq t}{\lor} \overleftarrow{trans_{t'}}) \land (\underset{t' \in T: t_\epsilon = \alpha?}{\lor} \overleftarrow{trans_{t'}})\) \\
\midrule
\(\phi_{15} := \underset{t \in T: t_\epsilon = \alpha?}{\bigwedge} \overleftarrow{trans_t} \Rightarrow (\neg \underset{t' \in T:t_\epsilon = \alpha?\land t'\neq t}{\lor} \overleftarrow{trans_{t'}}) \land (\underset{t' \in T:t_\epsilon = a!}{\lor} \overleftarrow{trans_{t'}})\) \\
\midrule
\(\phi_{16} := \underset{t \in T:t_\epsilon = \alpha\#}{\bigwedge} \overleftarrow{trans_t} \Rightarrow (\neg \underset{t' \in T:t_\epsilon = \alpha\#\land t' \neq t}{\lor} \overleftarrow{trans_{t'}}) \) \\
\midrule
\(\phi_{17} := \underset{\alpha \in Act}{\bigwedge}\ \underset{l \in [0,k+2]}{\underset{i \in [1,|\mathcal{A}|]}{\bigwedge}} (\underset{t_\epsilon = \alpha\#}{\underset{t \in T_i:}{\lor}} \overleftarrow{trans_t}^{[l]}) \Rightarrow \) \\
\(\underset{}{\underset{j \in [1,k]:}{\bigwedge}} (\underset{t'_\epsilon = \alpha@}{\underset{t' \in T_j: }{\lor}} (\overleftarrow{state_{t'_-}}^{[l]} \land \sigma_c(l) + \delta(l) \vDash t'_{\gamma_c} \land \sigma_v(l) \vDash t'_{\gamma_v}) \Rightarrow \underset{t'_\epsilon = \alpha@}{\underset{t' \in T_j:}{\lor}} \overleftarrow{trans_{t'}}^{[l]}) \) \\
\midrule
\(\phi_{18} := \underset{t \in T:t_\epsilon = \alpha@}{\bigwedge} \overleftarrow{trans_t} \Rightarrow (\underset{t' \in T: t_\epsilon = \alpha\#}{\lor} \overleftarrow{trans_{t'}}) \) \\

\end{tabular}
\end{center}

Different Timed Automata in our network use the synchronization channels in
\(Act_\tau\) to communicate and coordinate their transitions between states.
Each element in \(Act\) consists of a channel, which we will represent with
Greek letters \(\alpha, \beta, etc\), and an action to be performed over the
channel. Our implementation supports four actions which are represented using
four punctuation symbols. The first two, \(send(!)\) and \(receive(?)\), capture
one-to-one communication. For every channel \(\alpha\) there can be at most one
active transition with \(\alpha!\), and similarly at most one active transition
with \(\alpha?\). Informally this means that only one timed automaton can send
over the channel at a time, and only one can receive at a time. Furthermore each
send must be matched by a receive and vice versa. Formula \(\phi_{14}\) captures
these semantics for a transition with action \(\alpha!\) for some channel
\(\alpha\). Such a transition implies that no other transition with the action
\(\alpha!\) can be active in the same time instance, and furthermore one of the
transitions with the action \(\alpha?\) must be active. Formula \(\phi_{15}\)
captures the same constraints from the point of view of the receiving
transition. A transition with action \(\alpha?\) implies both that no other
receiving transition is active, and also that there exists an active sending
transition over the same channel.

The second pair of synchronization communication is termed ``broadcast
synchronization''. Like the one-to-one communication, there is a broadcast send
(\#) and a broadcast receive (@). However there are several differences in the
semantics of broadcast signals. To begin, while a broadcast receive signal must
be matched with a broadcast send, the reverse is not true, and a broadcast send
signal can be matched with any number of broadcast receives, including zero.
While multiple broadcast receive signals on the channel can be fired at the same
time, there can only be one broadcast send signal at a time per channel. The
other important distinction is that the broadcast send signal ``compels'' the
other Timed Automata to respond with broadcast receive if they are able to. By
this we mean that when a Timed Automaton fires a transition with a broadcast-send event, all other Timed Automata with an available transition containing
a broadcast-receive signal (on the same communication channel) must take the
transition. By ``available'' we mean that the Timed automaton is in the source
state of the transition and all of the clock and variable guards are satisfied.
Formulas \(\phi_{16}\) and \(\phi_{18}\) describe these constraints for
broadcast send and receive, respectively, while formula \(\phi_{17}\) describes
the ``compulsive'' nature of the broadcast-send transition.
\subsection{Loop Constraints}\label{constraints-loop}

\begin{center}
\begin{tabular}{c}
Loop Constraints \\
\midrule
\(\phi_{19} := \underset{i \in [1,|\mathcal{A}|]}{\bigwedge}\ \underset{j \in [1,\lceil\log_2 |\mathcal{T}_i|\rceil]}{\bigwedge} \overleftarrow{tb_j}^{[k+1]} = \overleftarrow{tb_j}^{[loop]}\) \\
\midrule
\(\phi_{20} := \underset{v \in Int}{\bigwedge}\ \underset{j \in [1,\lambda(v)]}{\bigwedge} \overleftarrow{vb_j}^{[k+1]} = \overleftarrow{vb_j}^{[loop]}\) \\
\midrule
\(\phi_{21} := \underset{c \in X}{\bigwedge} (\lfloor c(k+1) \rfloor\ = \lfloor c(loop) \rfloor) \lor (\lfloor c(k+1) \rfloor\ > \max(c) \land \lfloor c(loop) \rfloor > \max(c)) \) \\
\midrule
\(\phi_{22} := \underset{c \in X}{\bigwedge} \lfloor c(loop) \rfloor < \max(c) \Rightarrow (frac(c(k+1)) = 0) \Leftrightarrow (frac(c(loop)) = 0)\) \\
\midrule
\(\phi_{23} := \underset{c,c' \in X}{\bigwedge} frac(c(k+1)) < frac(c'(k+1)) \Leftrightarrow frac(c(loop)) < frac(c'(loop))\) \\
\midrule
\(\phi_{24} := \underset{c \in X}{\bigwedge} c(k) > \max(c) \lor (( \underset{t: c \in t_{\gamma_c}}{\BitOr}\overleftarrow{trans_t}) \BitAnd \overleftarrow{inloop} \neq \overleftarrow{0})\) \\
\end{tabular}
\end{center}

As mentioned previously, we are only interested in lasso-shaped runs that end in
a loop. To keep track of the initial position of the loop, we declare the
variable \(loop\), and constrain it to have a value in the range \([1,k]\).

Intuitively, the time position \(k+1\) represents the first time position in the
next iteration of the loop. It is effectively a `copy' of the position
\(loop\), however we add it as a distinct position so that we may capture
the semantics of the transition between time position \(k\) and time position
\(loop\). We therefore must introduce constraints to ensure that these two
positions are in fact equivalent. This requires that the active state and
transition of each timed automata at instance \(k+1\) be equal to that at
instance \(loop\). Formula \(\phi_{19}\) captures this by requiring that
for each Timed Automaton, each transition bit \(tb_i\) contains the same value
at time instances \(k+1\) and \(loop\). Similarly, formula \(\phi_{20}\)
enforces the same requirement for each bounded integer variable.

It is tempting to encode the clock constraints in a similar manner, requiring
that \(c(k+1) = c(loop)\) for each clock. However prior work by Kindermann[ref]
has shown that this constraint is not complete, as it excludes valid
lasso-shaped runs. To remedy this problem we use the requirements suggested by
Kindermann. To begin, for each clock \(c\) we define the non-negative integer
\(\max(c)\), which is equal to the maximum value either assigned to the clock in
a clock assignment or compared against the clock in a clock guard. We also
define \(frac(c(l))\), which is equal to the fractional part of \(c\) at time
instance \(l\), or \(frac(c(l)) = c(l) - \lfloor c(l) \rfloor\). Formulas
\(\phi_{21}\), \(\phi_{22}\), and \(\phi_{23}\) encode the desired requirements.
\(\phi_{21}\) encodes the first part of the relationship between \(c(loop)\) and
\(c(k+1)\). It states that either both values are greater than \(\max(c)\), or
both have the same floor. This is the first part of the region encoding.
\(\phi_{22}\) handles the special case where the fractional part of the value is
equal to zero. Since clock guards can test for equality, if the clock value is
less than \(\max(c)\), either the clock value at both time instances has a
fractional value of 0 or neither do. Finally, \(\phi_{23}\) completes the region
encoding by considering the relationship between values of different clocks,
asserting that the relationship between two clock values \(\{<,>,=\}\) is
preserved.

Unfortunately, there is one more consideration we must make in this section. The
culprit are so-called ``Zeno traces'', named because while they are lasso-shaped
runs with an infinite number of transitions, their execution happens in finite
time. Time in these traces is said to ``slow down'', because often each successive
loop of the lasso executes in a smaller amount of time than the loop before.
Because these represent unrealistic scenarios, they are often excluded from
consideration in many TA models. It is sufficient to require that every clock is
either reset within the loop, or has a value greater than \(max(c)\) at position
\(k\), which is shown in \(\phi_{24}\). The vector \(\overleftarrow{inloop}\)
has length \(k+2\), and each bit \(i\) is 1 iff \(i \geq loop\). Using this
vector, we can determine if a given clock is reset within the loop portion of
the trace.


\section{Evaluation}\label{evaluation}
In this chapter we present the results of several experimental evaluations of
the SMT conversion process. These tests cover several different benchmarks
common for bounded model checking programs. For comparison, results are
presented alongside those of the previous iteration of the TACK program, to
better judge the improvements made using the new process.

In all of the following tests, the time provided measures the combined time
taken by both the TACK program to parse the problem and convert it to SMT form and
the z3 program to decide the satisfiability of the SMT problem. In practice,
the time taken by z3 dwarfs the time used by the TACK translation, and for the
problem sizes encountered below the time taken by the TACK translation was always
negligible. For every test below, the evaluation proceeded in several rounds,
each with a larger bound on the length of traces considered by TACK. The data
obtained demonstrates how the running time of each program scales with the size
of the search space.

All tests were performed on a server equipped with an Intel(R) Core(TM) i7-4770
CPU (3.40 GHz) with 8 cores, 16 GB of RAM and Debian Linux (version 4.19).



\subsection{Fischer Mutual Exclusion Protocol}\label{evaluation-fischer}
The Fischer benchmark models a protocol for ensuring exclusive access to a
shared common resource that can be requested by multiple processes. The protocol
uses global variables, integrated into the guards and assignment statements of
the timed automata, to control access. Each timed automaton in the network has a
'critical state', and the protocol guarantees that only one timed automaton can
be in its critical state at a time.

To be more specific, there is a shared variable \(id\), which can take any
integer value in the range \([0,n]\), where \(n\) is the number of processes in the
protocol. Each process begins in an 'idle' state \(a\), and in order to reach the
critical section \(cs\), a process must first check to see that the critical
section is unoccupied (\(id=0\)), at which point the process writes its own id to
the shared variable (while entering state \(b\)) and then performs a second
transition to state \(c\) within 2 seconds of entering state \(b\). The process is
then required to wait at least 2 seconds in state \(c\). If after that interval
the value of the shared variable is still equal to its id, the process may access
the critical section, otherwise it must wait for the value of \(id\) to return
to \(0\) before trying again (returning to \(b\)). Once access to the critical
section is granted, the process may remain for an unlimited amount of time before
returning to state \(a\).

To measure the scalability of our program, in addition to modifying the bound
\(k\), we performed multiple test runs while modifying the number of timed
automata in the network that are attempting to execute their critical region.
Aside from a numerical id, these processes are identical in their behavior.
In addition to testing the scalability of the program, we have also run the
Fischer protocol through several different MITL properties for verification.
These properties will be explained below.

\begin{align}
&Property 1 &&:=&& \mathcal{G}_{[0,\infty)}\ (p_1.b \Rightarrow \mathcal{F}_{[0,\infty)}p_1.c) &\nonumber \\
&Property 2 &&:=&& \mathcal{G}_{[0,\infty)}\ (p_1.b \Rightarrow \mathcal{F}_{[0,3]}p_1.c) &\nonumber \\
&Property 3 &&:=&& \mathcal{G}_{[0,\infty)}\ (p_1.b \Rightarrow \mathcal{F}_{(0,3)}p_1.cs) &\nonumber \\
&Property 4 &&:=&& \mathcal{G}_{[0,\infty)}\ (p_1.b \Rightarrow \mathcal{F}_{(0,3)}p_1.c) &\nonumber \\
&Property 5 &&:=&& \mathcal{G}_{[0,\infty)}\ (p_1.b \Rightarrow \mathcal{F}_{[0,3]}p_1.cs) &\nonumber \\
&Property 6 &&:=&& \mathcal{G}_{[0,\infty)}\ \neg (\underset{i=1:n-1}{\lor} (p_i.cs \land \underset{j=i+1:n}{\lor} p_j.cs ))  &\nonumber
\end{align}

Property 1 requires that once process one enters state \(b\), it always
transitions to state \(c\). Property 2 is similar, however it contains the
additional constraint that process 1 must complete the transition to state \(c\)
in at most 3 seconds. Property 3 has a similar time bound, but requires that
process one move to the critical section \(cs\) rather than \(c\) within the
time bound, which we expect to not be universally true (a process can return to
state \(b\) after moving to state \(c\) if another process has reset the
variable \(id\)). Properties 4 and 5 are copies of properties 2 and 3
respectively with the sole difference of inclusion vs exclusion at the
boundaries of the interval. Property 6 seeks to prove the ``safety'' of the
protocol, namely that two distinct processes are never in the critical section
at the same time.


\begin{table}
\setstretch{0.6}
\center
\caption{Time required to solve the Fischer Benchmark Properties}
\begin{tabular}{c|c|r r r r r r r r r}
\toprule
\multicolumn{11}{c}{TACK ae2sbvzot} \\
\midrule
\multicolumn{11}{c}{\(n\)} \\
\midrule
& k & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
\midrule
\multirow{5}{1em}{\rotatebox{90}{live-one}}
& 10 & 0.9 & 0.9 & 1.0 & 1.0 & 1.2 & 1.2 & 1.5 & 6.0 & 1.7 \\
& 15 & 0.9 & 0.9 & 1.1 & 1.4 & 1.6 & 1.7 & 1.5 & 14.2 & 2.1 \\
& 20 & 1.0 & 1.1 & 1.3 & 2.2 & 1.9 & 2.6 & 2.4 & 3.6 & 3.9 \\
& 25 & 1.1 & 1.6 & 1.5 & 2.1 & 189.8 & 3.4 & 4.9 & 4.5 & 4.6 \\
& 30 & 1.1 & 1.5 & 2.0 & 3.1 & 6.4 & 4.5 & 4.9 & 4.7 & 4.8 \\
\midrule
\multirow{5}{1em}{\rotatebox{90}{live-two}}
& 10 & 1.4 & 1.6 & 1.7 & 2.0 & 2.0 & 2.4 & 2.5 & 2.7 & 3.1 \\
& 15 & 4.5 & 6.3 & 6.0 & 9.7 & 15.0 & 27.0 & 48.4 & 67.4 & 146.5 \\
& 20 & 10.8 & 13.0 & 37.5 & 22.1 & 56.6 & 36.8 & 56.8 & 567.9 & 1589.1 \\
& 25 & 32.6 & 39.3 & 57.3 & 131.8 & 102.4 & 2369.2 & 1614.3 & 1197.9 & 6311.7 \\
& 30 & 42.4 & 80.7 & 127.7 & 63.8 & 1149.1 & 125.9 & $-$ & $-$ & $-$ \\
\midrule
\multirow{5}{1em}{\rotatebox{90}{live-three}}
& 10 & 1.0 & 1.1 & 1.6 & 3.6 & 8.0 & 13.2 & 19.5 & 17.6 & 26.7 \\
& 15 & 1.2 & 1.3 & 2.5 & 2.0 & 18.5 & 27.6 & 30.6 & 59.4 & 41.2 \\
& 20 & 1.2 & 1.8 & 2.1 & 4.2 & 8.0 & 10.4 & 23.9 & 33.1 & 64.7 \\
& 25 & 2.0 & 2.3 & 3.7 & 5.9 & 9.5 & 24.1 & 681.5 & 753.3 & 826.9 \\
& 30 & 1.5 & 4.6 & 4.6 & 8.8 & 32.7 & 24.4 & 30.7 & 102.8 & 150.1 \\
\midrule
\multirow{5}{1em}{\rotatebox{90}{live-four}}
& 10 & 1.2 & 1.3 & 1.5 & 1.7 & 1.9 & 2.1 & 2.1 & 2.4 & 2.3 \\
& 15 & 2.9 & 3.6 & 5.0 & 8.0 & 11.2 & 19.6 & 33.9 & 74.8 & 130.9 \\
& 20 & 6.6 & 15.5 & 14.4 & 17.7 & 77.7 & 86.2 & 183.5 & 504.3 & 1516.6 \\
& 25 & 10.3 & 17.8 & 22.9 & 45.5 & 151.4 & 2482.6 & 2406.0 & 6578.4 & $-$ \\
& 30 & 27.5 & 26.2 & 33.9 & 56.0 & 67.0 & 217.1 & 1717.2 & 291.6 & 462.5 \\
\midrule
\multirow{5}{1em}{\rotatebox{90}{live-five}}
& 10 & 1.1 & 1.3 & 1.9 & 1.8 & 5.4 & 13.7 & 24.0 & 22.9 & 23.7 \\
& 15 & 1.3 & 1.7 & 2.5 & 2.3 & 5.3 & 5.7 & 20.3 & $-$ & 36.8 \\
& 20 & 1.7 & 2.2 & 2.6 & 5.2 & 8.6 & 15.2 & 29.8 & 71.2 & $-$ \\
& 25 & 2.1 & 3.6 & 4.4 & 13.5 & 10.6 & 17.2 & 781.3 & 816.1 & 569.4 \\
& 30 & 2.2 & 6.9 & 5.6 & 14.9 & 21.1 & 26.7 & 28.8 & 140.6 & 238.6 \\
\midrule
\multirow{5}{1em}{\rotatebox{90}{live-six}}
& 10 & 0.9 & 1.1 & 1.9 & 2.5 & 3.1 & 4.7 & 10.1 & 7.9 & 16.2 \\
& 15 & 1.0 & 1.8 & 4.4 & 10.0 & 33.9 & 51.2 & 84.0 & 110.9 & 191.5 \\
& 20 & 1.5 & 3.9 & 10.2 & 21.6 & 93.3 & 234.8 & 670.4 & 1000.4 & $-$ \\
& 25 & 1.7 & 8.9 & 27.6 & 83.5 & 188.1 & 596.2 & 2469.2 & 5365.0 & $-$ \\
& 30 & 2.5 & 16.3 & 54.4 & 263.4 & 993.9 & 3354.1 & $-$ & $-$ & $-$ \\

\midrule
\multicolumn{11}{c}{TACK ta2smt} \\
\midrule
\multicolumn{11}{c}{\(n\)} \\
\midrule
& k & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
\midrule




\end{tabular}
\end{table}

\subsection{CSMA/CD}\label{evaluation-csma}
\subsection{Token Ring}\label{evaluation-token}

The Token Ring protocol models a ring of processes that pass a token between
themselves, along with a process that models the ring itself.

\section{Conclusion}\label{conclusion}
\end{document}
